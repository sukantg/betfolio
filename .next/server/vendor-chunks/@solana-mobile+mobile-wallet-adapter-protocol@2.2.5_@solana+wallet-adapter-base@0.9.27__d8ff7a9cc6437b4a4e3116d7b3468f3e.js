"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana-mobile+mobile-wallet-adapter-protocol@2.2.5_@solana+wallet-adapter-base@0.9.27__d8ff7a9cc6437b4a4e3116d7b3468f3e";
exports.ids = ["vendor-chunks/@solana-mobile+mobile-wallet-adapter-protocol@2.2.5_@solana+wallet-adapter-base@0.9.27__d8ff7a9cc6437b4a4e3116d7b3468f3e"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@solana-mobile+mobile-wallet-adapter-protocol@2.2.5_@solana+wallet-adapter-base@0.9.27__d8ff7a9cc6437b4a4e3116d7b3468f3e/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js":
/*!*********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana-mobile+mobile-wallet-adapter-protocol@2.2.5_@solana+wallet-adapter-base@0.9.27__d8ff7a9cc6437b4a4e3116d7b3468f3e/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js ***!
  \*********************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaCloneAuthorization: () => (/* binding */ SolanaCloneAuthorization),\n/* harmony export */   SolanaMobileWalletAdapterError: () => (/* binding */ SolanaMobileWalletAdapterError),\n/* harmony export */   SolanaMobileWalletAdapterErrorCode: () => (/* binding */ SolanaMobileWalletAdapterErrorCode),\n/* harmony export */   SolanaMobileWalletAdapterProtocolError: () => (/* binding */ SolanaMobileWalletAdapterProtocolError),\n/* harmony export */   SolanaMobileWalletAdapterProtocolErrorCode: () => (/* binding */ SolanaMobileWalletAdapterProtocolErrorCode),\n/* harmony export */   SolanaSignInWithSolana: () => (/* binding */ SolanaSignInWithSolana),\n/* harmony export */   SolanaSignTransactions: () => (/* binding */ SolanaSignTransactions),\n/* harmony export */   startRemoteScenario: () => (/* binding */ startRemoteScenario),\n/* harmony export */   transact: () => (/* binding */ transact)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/./node_modules/.pnpm/@solana+wallet-standard-util@1.1.2/node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\");\n/* harmony import */ var _solana_codecs_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-strings */ \"(ssr)/./node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/dist/index.node.mjs\");\n\n\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterErrorCode = {\n    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: 'ERROR_ASSOCIATION_PORT_OUT_OF_RANGE',\n    ERROR_REFLECTOR_ID_OUT_OF_RANGE: 'ERROR_REFLECTOR_ID_OUT_OF_RANGE',\n    ERROR_FORBIDDEN_WALLET_BASE_URL: 'ERROR_FORBIDDEN_WALLET_BASE_URL',\n    ERROR_SECURE_CONTEXT_REQUIRED: 'ERROR_SECURE_CONTEXT_REQUIRED',\n    ERROR_SESSION_CLOSED: 'ERROR_SESSION_CLOSED',\n    ERROR_SESSION_TIMEOUT: 'ERROR_SESSION_TIMEOUT',\n    ERROR_WALLET_NOT_FOUND: 'ERROR_WALLET_NOT_FOUND',\n    ERROR_INVALID_PROTOCOL_VERSION: 'ERROR_INVALID_PROTOCOL_VERSION',\n    ERROR_BROWSER_NOT_SUPPORTED: 'ERROR_BROWSER_NOT_SUPPORTED',\n};\nclass SolanaMobileWalletAdapterError extends Error {\n    constructor(...args) {\n        const [code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.name = 'SolanaMobileWalletAdapterError';\n    }\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterProtocolErrorCode = {\n    // Keep these in sync with `mobilewalletadapter/common/ProtocolContract.java`.\n    ERROR_AUTHORIZATION_FAILED: -1,\n    ERROR_INVALID_PAYLOADS: -2,\n    ERROR_NOT_SIGNED: -3,\n    ERROR_NOT_SUBMITTED: -4,\n    ERROR_TOO_MANY_PAYLOADS: -5,\n    ERROR_ATTEST_ORIGIN_ANDROID: -100,\n};\nclass SolanaMobileWalletAdapterProtocolError extends Error {\n    constructor(...args) {\n        const [jsonRpcMessageId, code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.jsonRpcMessageId = jsonRpcMessageId;\n        this.name = 'SolanaMobileWalletAdapterProtocolError';\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction encode(input) {\n    return window.btoa(input);\n}\nfunction fromUint8Array$1(byteArray, urlsafe) {\n    const base64 = window.btoa(String.fromCharCode.call(null, ...byteArray));\n    if (urlsafe) {\n        return base64\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=+$/, '');\n    }\n    else\n        return base64;\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window\n        .atob(base64EncodedByteArray)\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n}\n\nfunction createHelloReq(ecdhPublicKey, associationKeypairPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const publicKeyBuffer = yield crypto.subtle.exportKey('raw', ecdhPublicKey);\n        const signatureBuffer = yield crypto.subtle.sign({ hash: 'SHA-256', name: 'ECDSA' }, associationKeypairPrivateKey, publicKeyBuffer);\n        const response = new Uint8Array(publicKeyBuffer.byteLength + signatureBuffer.byteLength);\n        response.set(new Uint8Array(publicKeyBuffer), 0);\n        response.set(new Uint8Array(signatureBuffer), publicKeyBuffer.byteLength);\n        return response;\n    });\n}\n\nfunction createSIWSMessage(payload) {\n    return (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__.createSignInMessageText)(payload);\n}\nfunction createSIWSMessageBase64Url(payload) {\n    return encode(createSIWSMessage(payload))\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=+$/, ''); // convert to base64url encoding;\n}\n\n// optional features\nconst SolanaSignTransactions = 'solana:signTransactions';\nconst SolanaCloneAuthorization = 'solana:cloneAuthorization';\nconst SolanaSignInWithSolana = 'solana:signInWithSolana';\n\nfunction fromUint8Array(byteArray) {\n    return (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_1__.getBase58Decoder)().decode(byteArray);\n}\nfunction base64ToBase58(base64EncodedString) {\n    return fromUint8Array(toUint8Array(base64EncodedString));\n}\n\n/**\n * Creates a {@link MobileWallet} proxy that handles backwards compatibility and API to RPC conversion.\n *\n * @param protocolVersion the protocol version in use for this session/request\n * @param protocolRequestHandler callback function that handles sending the RPC request to the wallet endpoint.\n * @returns a {@link MobileWallet} proxy\n */\nfunction createMobileWalletProxy(protocolVersion, protocolRequestHandler) {\n    return new Proxy({}, {\n        get(target, p) {\n            // Wrapping a Proxy in a promise results in the Proxy being asked for a 'then' property so must \n            // return null if 'then' is called on this proxy to let the 'resolve()' call know this is not a promise.\n            // see: https://stackoverflow.com/a/53890904\n            //@ts-ignore\n            if (p === 'then') {\n                return null;\n            }\n            if (target[p] == null) {\n                target[p] = function (inputParams) {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        const { method, params } = handleMobileWalletRequest(p, inputParams, protocolVersion);\n                        const result = yield protocolRequestHandler(method, params);\n                        // if the request tried to sign in but the wallet did not return a sign in result, fallback on message signing\n                        if (method === 'authorize' && params.sign_in_payload && !result.sign_in_result) {\n                            result['sign_in_result'] = yield signInFallback(params.sign_in_payload, result, protocolRequestHandler);\n                        }\n                        return handleMobileWalletResponse(p, result, protocolVersion);\n                    });\n                };\n            }\n            return target[p];\n        },\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n    });\n}\n/**\n * Handles all {@link MobileWallet} API requests and determines the correct MWA RPC method and params to call.\n * This handles backwards compatibility, based on the provided @protocolVersion.\n *\n * @param methodName the name of {@link MobileWallet} method that was called\n * @param methodParams the parameters that were passed to the method\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the RPC request method and params that should be sent to the wallet endpoint\n */\nfunction handleMobileWalletRequest(methodName, methodParams, protocolVersion) {\n    let params = methodParams;\n    let method = methodName\n        .toString()\n        .replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n        .toLowerCase();\n    switch (methodName) {\n        case 'authorize': {\n            let { chain } = params;\n            if (protocolVersion === 'legacy') {\n                switch (chain) {\n                    case 'solana:testnet': {\n                        chain = 'testnet';\n                        break;\n                    }\n                    case 'solana:devnet': {\n                        chain = 'devnet';\n                        break;\n                    }\n                    case 'solana:mainnet': {\n                        chain = 'mainnet-beta';\n                        break;\n                    }\n                    default: {\n                        chain = params.cluster;\n                    }\n                }\n                params.cluster = chain;\n            }\n            else {\n                switch (chain) {\n                    case 'testnet':\n                    case 'devnet': {\n                        chain = `solana:${chain}`;\n                        break;\n                    }\n                    case 'mainnet-beta': {\n                        chain = 'solana:mainnet';\n                        break;\n                    }\n                }\n                params.chain = chain;\n            }\n        }\n        case 'reauthorize': {\n            const { auth_token, identity } = params;\n            if (auth_token) {\n                switch (protocolVersion) {\n                    case 'legacy': {\n                        method = 'reauthorize';\n                        params = { auth_token: auth_token, identity: identity };\n                        break;\n                    }\n                    default: {\n                        method = 'authorize';\n                        break;\n                    }\n                }\n            }\n            break;\n        }\n    }\n    return { method, params };\n}\n/**\n * Handles all {@link MobileWallet} API responses and modifies the response for backwards compatibility, if needed\n *\n * @param method the {@link MobileWallet} method that was called\n * @param response the original response that was returned by the method call\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the possibly modified response\n */\nfunction handleMobileWalletResponse(method, response, protocolVersion) {\n    switch (method) {\n        case 'getCapabilities': {\n            const capabilities = response;\n            switch (protocolVersion) {\n                case 'legacy': {\n                    const features = [SolanaSignTransactions];\n                    if (capabilities.supports_clone_authorization === true) {\n                        features.push(SolanaCloneAuthorization);\n                    }\n                    return Object.assign(Object.assign({}, capabilities), { features: features });\n                }\n                case 'v1': {\n                    return Object.assign(Object.assign({}, capabilities), { supports_sign_and_send_transactions: true, supports_clone_authorization: capabilities.features.includes(SolanaCloneAuthorization) });\n                }\n            }\n        }\n    }\n    return response;\n}\nfunction signInFallback(signInPayload, authorizationResult, protocolRequestHandler) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const domain = (_a = signInPayload.domain) !== null && _a !== void 0 ? _a : window.location.host;\n        const address = authorizationResult.accounts[0].address;\n        const siwsMessage = createSIWSMessageBase64Url(Object.assign(Object.assign({}, signInPayload), { domain, address: base64ToBase58(address) }));\n        const signMessageResult = yield protocolRequestHandler('sign_messages', {\n            addresses: [address],\n            payloads: [siwsMessage]\n        });\n        const signedPayload = toUint8Array(signMessageResult.signed_payloads[0]);\n        const signedMessage = fromUint8Array$1(signedPayload.slice(0, signedPayload.length - 64));\n        const signature = fromUint8Array$1(signedPayload.slice(signedPayload.length - 64));\n        const signInResult = {\n            address: address,\n            // Workaround: some wallets have been observed to only reply with the message signature.\n            // This is non-compliant with the spec, but in the interest of maximizing compatibility,\n            // detect this case and reuse the original message.\n            signed_message: signedMessage.length == 0 ? siwsMessage : signedMessage,\n            signature\n        };\n        return signInResult;\n    });\n}\n\nconst SEQUENCE_NUMBER_BYTES = 4;\nfunction createSequenceNumberVector(sequenceNumber) {\n    if (sequenceNumber >= 4294967296) {\n        throw new Error('Outbound sequence number overflow. The maximum sequence number is 32-bytes.');\n    }\n    const byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);\n    const view = new DataView(byteArray);\n    view.setUint32(0, sequenceNumber, /* littleEndian */ false);\n    return new Uint8Array(byteArray);\n}\n\nconst INITIALIZATION_VECTOR_BYTES = 12;\nconst ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;\nfunction encryptMessage(plaintext, sequenceNumber, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sequenceNumberVector = createSequenceNumberVector(sequenceNumber);\n        const initializationVector = new Uint8Array(INITIALIZATION_VECTOR_BYTES);\n        crypto.getRandomValues(initializationVector);\n        const ciphertext = yield crypto.subtle.encrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, new TextEncoder().encode(plaintext));\n        const response = new Uint8Array(sequenceNumberVector.byteLength + initializationVector.byteLength + ciphertext.byteLength);\n        response.set(new Uint8Array(sequenceNumberVector), 0);\n        response.set(new Uint8Array(initializationVector), sequenceNumberVector.byteLength);\n        response.set(new Uint8Array(ciphertext), sequenceNumberVector.byteLength + initializationVector.byteLength);\n        return response;\n    });\n}\nfunction decryptMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sequenceNumberVector = message.slice(0, SEQUENCE_NUMBER_BYTES);\n        const initializationVector = message.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const ciphertext = message.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const plaintextBuffer = yield crypto.subtle.decrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, ciphertext);\n        const plaintext = getUtf8Decoder().decode(plaintextBuffer);\n        return plaintext;\n    });\n}\nfunction getAlgorithmParams(sequenceNumber, initializationVector) {\n    return {\n        additionalData: sequenceNumber,\n        iv: initializationVector,\n        name: 'AES-GCM',\n        tagLength: 128, // 16 byte tag => 128 bits\n    };\n}\nlet _utf8Decoder;\nfunction getUtf8Decoder() {\n    if (_utf8Decoder === undefined) {\n        _utf8Decoder = new TextDecoder('utf-8');\n    }\n    return _utf8Decoder;\n}\n\nfunction generateAssociationKeypair() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield crypto.subtle.generateKey({\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n        }, false /* extractable */, ['sign'] /* keyUsages */);\n    });\n}\n\nfunction generateECDHKeypair() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield crypto.subtle.generateKey({\n            name: 'ECDH',\n            namedCurve: 'P-256',\n        }, false /* extractable */, ['deriveKey', 'deriveBits'] /* keyUsages */);\n    });\n}\n\n// https://stackoverflow.com/a/9458996/802047\nfunction arrayBufferToBase64String(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for (let ii = 0; ii < len; ii++) {\n        binary += String.fromCharCode(bytes[ii]);\n    }\n    return window.btoa(binary);\n}\n\nfunction getRandomAssociationPort() {\n    return assertAssociationPort(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)));\n}\nfunction assertAssociationPort(port) {\n    if (port < 49152 || port > 65535) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${port} given.`, { port });\n    }\n    return port;\n}\n\nfunction getStringWithURLUnsafeCharactersReplaced(unsafeBase64EncodedString) {\n    return unsafeBase64EncodedString.replace(/[/+=]/g, (m) => ({\n        '/': '_',\n        '+': '-',\n        '=': '.',\n    }[m]));\n}\n\nconst INTENT_NAME = 'solana-wallet';\nfunction getPathParts(pathString) {\n    return (pathString\n        // Strip leading and trailing slashes\n        .replace(/(^\\/+|\\/+$)/g, '')\n        // Return an array of directories\n        .split('/'));\n}\nfunction getIntentURL(methodPathname, intentUrlBase) {\n    let baseUrl = null;\n    if (intentUrlBase) {\n        try {\n            baseUrl = new URL(intentUrlBase);\n        }\n        catch (_a) { } // eslint-disable-line no-empty\n        if ((baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.protocol) !== 'https:') {\n            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');\n        }\n    }\n    baseUrl || (baseUrl = new URL(`${INTENT_NAME}:/`));\n    const pathname = methodPathname.startsWith('/')\n        ? // Method is an absolute path. Replace it wholesale.\n            methodPathname\n        : // Method is a relative path. Merge it with the existing one.\n            [...getPathParts(baseUrl.pathname), ...getPathParts(methodPathname)].join('/');\n    return new URL(pathname, baseUrl);\n}\nfunction getAssociateAndroidIntentURL(associationPublicKey, putativePort, associationURLBase, protocolVersions = ['v1']) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const associationPort = assertAssociationPort(putativePort);\n        const exportedKey = yield crypto.subtle.exportKey('raw', associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL('v1/associate/local', associationURLBase);\n        url.searchParams.set('association', getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set('port', `${associationPort}`);\n        protocolVersions.forEach((version) => {\n            url.searchParams.set('v', version);\n        });\n        return url;\n    });\n}\nfunction getRemoteAssociateAndroidIntentURL(associationPublicKey, hostAuthority, reflectorId, associationURLBase, protocolVersions = ['v1']) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const exportedKey = yield crypto.subtle.exportKey('raw', associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL('v1/associate/remote', associationURLBase);\n        url.searchParams.set('association', getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set('reflector', `${hostAuthority}`);\n        url.searchParams.set('id', `${fromUint8Array$1(reflectorId, true)}`);\n        protocolVersions.forEach((version) => {\n            url.searchParams.set('v', version);\n        });\n        return url;\n    });\n}\n\nfunction encryptJsonRpcMessage(jsonRpcMessage, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = JSON.stringify(jsonRpcMessage);\n        const sequenceNumber = jsonRpcMessage.id;\n        return encryptMessage(plaintext, sequenceNumber, sharedSecret);\n    });\n}\nfunction decryptJsonRpcMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonRpcMessage = JSON.parse(plaintext);\n        if (Object.hasOwnProperty.call(jsonRpcMessage, 'error')) {\n            throw new SolanaMobileWalletAdapterProtocolError(jsonRpcMessage.id, jsonRpcMessage.error.code, jsonRpcMessage.error.message);\n        }\n        return jsonRpcMessage;\n    });\n}\n\nfunction parseHelloRsp(payloadBuffer, // The X9.62-encoded wallet endpoint ephemeral ECDH public keypoint.\nassociationPublicKey, ecdhPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [associationPublicKeyBuffer, walletPublicKey] = yield Promise.all([\n            crypto.subtle.exportKey('raw', associationPublicKey),\n            crypto.subtle.importKey('raw', payloadBuffer.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), { name: 'ECDH', namedCurve: 'P-256' }, false /* extractable */, [] /* keyUsages */),\n        ]);\n        const sharedSecret = yield crypto.subtle.deriveBits({ name: 'ECDH', public: walletPublicKey }, ecdhPrivateKey, 256);\n        const ecdhSecretKey = yield crypto.subtle.importKey('raw', sharedSecret, 'HKDF', false /* extractable */, ['deriveKey'] /* keyUsages */);\n        const aesKeyMaterialVal = yield crypto.subtle.deriveKey({\n            name: 'HKDF',\n            hash: 'SHA-256',\n            salt: new Uint8Array(associationPublicKeyBuffer),\n            info: new Uint8Array(),\n        }, ecdhSecretKey, { name: 'AES-GCM', length: 128 }, false /* extractable */, ['encrypt', 'decrypt']);\n        return aesKeyMaterialVal;\n    });\n}\n\nfunction parseSessionProps(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonProperties = JSON.parse(plaintext);\n        let protocolVersion = 'legacy';\n        if (Object.hasOwnProperty.call(jsonProperties, 'v')) {\n            switch (jsonProperties.v) {\n                case 1:\n                case '1':\n                case 'v1':\n                    protocolVersion = 'v1';\n                    break;\n                case 'legacy':\n                    protocolVersion = 'legacy';\n                    break;\n                default:\n                    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${jsonProperties.v}`);\n            }\n        }\n        return ({\n            protocol_version: protocolVersion\n        });\n    });\n}\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst Browser = {\n    Firefox: 0,\n    Other: 1,\n};\nfunction assertUnreachable(x) {\n    return x;\n}\nfunction getBrowser() {\n    return navigator.userAgent.indexOf('Firefox/') !== -1 ? Browser.Firefox : Browser.Other;\n}\nfunction getDetectionPromise() {\n    // Chrome and others silently fail if a custom protocol is not supported.\n    // For these, we wait to see if the browser is navigated away from in\n    // a reasonable amount of time (ie. the native wallet opened).\n    return new Promise((resolve, reject) => {\n        function cleanup() {\n            clearTimeout(timeoutId);\n            window.removeEventListener('blur', handleBlur);\n        }\n        function handleBlur() {\n            cleanup();\n            resolve();\n        }\n        window.addEventListener('blur', handleBlur);\n        const timeoutId = setTimeout(() => {\n            cleanup();\n            reject();\n        }, 3000);\n    });\n}\nlet _frame = null;\nfunction launchUrlThroughHiddenFrame(url) {\n    if (_frame == null) {\n        _frame = document.createElement('iframe');\n        _frame.style.display = 'none';\n        document.body.appendChild(_frame);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    _frame.contentWindow.location.href = url.toString();\n}\nfunction launchAssociation(associationUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (associationUrl.protocol === 'https:') {\n            // The association URL is an Android 'App Link' or iOS 'Universal Link'.\n            // These are regular web URLs that are designed to launch an app if it\n            // is installed or load the actual target webpage if not.\n            window.location.assign(associationUrl);\n        }\n        else {\n            // The association URL has a custom protocol (eg. `solana-wallet:`)\n            try {\n                const browser = getBrowser();\n                switch (browser) {\n                    case Browser.Firefox:\n                        // If a custom protocol is not supported in Firefox, it throws.\n                        launchUrlThroughHiddenFrame(associationUrl);\n                        // If we reached this line, it's supported.\n                        break;\n                    case Browser.Other: {\n                        const detectionPromise = getDetectionPromise();\n                        window.location.assign(associationUrl);\n                        yield detectionPromise;\n                        break;\n                    }\n                    default:\n                        assertUnreachable(browser);\n                }\n            }\n            catch (e) {\n                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, 'Found no installed wallet that supports the mobile wallet protocol.');\n            }\n        }\n    });\n}\nfunction startSession(associationPublicKey, associationURLBase) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const randomAssociationPort = getRandomAssociationPort();\n        const associationUrl = yield getAssociateAndroidIntentURL(associationPublicKey, randomAssociationPort, associationURLBase);\n        yield launchAssociation(associationUrl);\n        return randomAssociationPort;\n    });\n}\n\nconst WEBSOCKET_CONNECTION_CONFIG = {\n    /**\n     * 300 milliseconds is a generally accepted threshold for what someone\n     * would consider an acceptable response time for a user interface\n     * after having performed a low-attention tapping task. We set the initial\n     * interval at which we wait for the wallet to set up the websocket at\n     * half this, as per the Nyquist frequency, with a progressive backoff\n     * sequence from there. The total wait time is 30s, which allows for the\n     * user to be presented with a disambiguation dialog, select a wallet, and\n     * for the wallet app to subsequently start.\n     */\n    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1000],\n    timeoutMs: 30000,\n};\nconst WEBSOCKET_PROTOCOL_BINARY = 'com.solana.mobilewalletadapter.v1';\nconst WEBSOCKET_PROTOCOL_BASE64 = 'com.solana.mobilewalletadapter.v1.base64';\nfunction assertSecureContext() {\n    if (typeof window === 'undefined' || window.isSecureContext !== true) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, 'The mobile wallet adapter protocol must be used in a secure context (`https`).');\n    }\n}\nfunction assertSecureEndpointSpecificURI(walletUriBase) {\n    let url;\n    try {\n        url = new URL(walletUriBase);\n    }\n    catch (_a) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Invalid base URL supplied by wallet');\n    }\n    if (url.protocol !== 'https:') {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');\n    }\n}\nfunction getSequenceNumberFromByteArray(byteArray) {\n    const view = new DataView(byteArray);\n    return view.getUint32(0, /* littleEndian */ false);\n}\nfunction decodeVarLong(byteArray) {\n    var bytes = new Uint8Array(byteArray), l = byteArray.byteLength, limit = 10, value = 0, offset = 0, b;\n    do {\n        if (offset >= l || offset > limit)\n            throw new RangeError('Failed to decode varint');\n        b = bytes[offset++];\n        value |= (b & 0x7F) << (7 * offset);\n    } while (b >= 0x80);\n    return { value, offset };\n}\nfunction getReflectorIdFromByteArray(byteArray) {\n    let { value: length, offset } = decodeVarLong(byteArray);\n    return new Uint8Array(byteArray.slice(offset, offset + length));\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const sessionPort = yield startSession(associationKeypair.publicKey, config === null || config === void 0 ? void 0 : config.baseUri);\n        const websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (() => {\n            const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];\n            return () => (schedule.length > 1 ? schedule.shift() : schedule[0]);\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let state = { __type: 'disconnected' };\n        return new Promise((resolve, reject) => {\n            let socket;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const jsonRpcResponsePromises = {};\n            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {\n                if (state.__type !== 'connecting') {\n                    console.warn('Expected adapter state to be `connecting` at the moment the websocket opens. ' +\n                        `Got \\`${state.__type}\\`.`);\n                    return;\n                }\n                socket.removeEventListener('open', handleOpen);\n                // previous versions of this library and walletlib incorrectly implemented the MWA session \n                // establishment protocol for local connections. The dapp is supposed to wait for the \n                // APP_PING message before sending the HELLO_REQ. Instead, the dapp was sending the HELLO_REQ \n                // immediately upon connection to the websocket server regardless of wether or not an \n                // APP_PING was sent by the wallet/websocket server. We must continue to support this behavior \n                // in case the user is using a wallet that has not updated their walletlib implementation. \n                const { associationKeypair } = state;\n                const ecdhKeypair = yield generateECDHKeypair();\n                socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                state = {\n                    __type: 'hello_req_sent',\n                    associationPublicKey: associationKeypair.publicKey,\n                    ecdhPrivateKey: ecdhKeypair.privateKey,\n                };\n            });\n            const handleClose = (evt) => {\n                if (evt.wasClean) {\n                    state = { __type: 'disconnected' };\n                }\n                else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt) => __awaiter(this, void 0, void 0, function* () {\n                disposeSocket();\n                if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                }\n                else {\n                    yield new Promise((resolve) => {\n                        const retryDelayMs = getNextRetryDelayMs();\n                        retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                    });\n                    attemptSocketConnection();\n                }\n            });\n            const handleMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                const responseBuffer = yield evt.data.arrayBuffer();\n                switch (state.__type) {\n                    case 'connecting':\n                        if (responseBuffer.byteLength !== 0) {\n                            throw new Error('Encountered unexpected message while connecting');\n                        }\n                        const ecdhKeypair = yield generateECDHKeypair();\n                        socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                        state = {\n                            __type: 'hello_req_sent',\n                            associationPublicKey: associationKeypair.publicKey,\n                            ecdhPrivateKey: ecdhKeypair.privateKey,\n                        };\n                        break;\n                    case 'connected':\n                        try {\n                            const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                            const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                            if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                throw new Error('Encrypted message has invalid sequence number');\n                            }\n                            lastKnownInboundSequenceNumber = sequenceNumber;\n                            const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                            const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                            delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                            responsePromise.resolve(jsonRpcMessage.result);\n                        }\n                        catch (e) {\n                            if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                responsePromise.reject(e);\n                            }\n                            else {\n                                throw e;\n                            }\n                        }\n                        break;\n                    case 'hello_req_sent': {\n                        // if we receive an APP_PING message (empty message), resend the HELLO_REQ (see above)\n                        if (responseBuffer.byteLength === 0) {\n                            const ecdhKeypair = yield generateECDHKeypair();\n                            socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                            state = {\n                                __type: 'hello_req_sent',\n                                associationPublicKey: associationKeypair.publicKey,\n                                ecdhPrivateKey: ecdhKeypair.privateKey,\n                            };\n                            break;\n                        }\n                        const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                        const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                        const sessionProperties = sessionPropertiesBuffer.byteLength !== 0\n                            ? yield (() => __awaiter(this, void 0, void 0, function* () {\n                                const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                    throw new Error('Encrypted message has invalid sequence number');\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                            }))() : { protocol_version: 'legacy' };\n                        state = { __type: 'connected', sharedSecret, sessionProperties };\n                        const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter(this, void 0, void 0, function* () {\n                            const id = nextJsonRpcMessageId++;\n                            socket.send(yield encryptJsonRpcMessage({\n                                id,\n                                jsonrpc: '2.0',\n                                method,\n                                params: params !== null && params !== void 0 ? params : {},\n                            }, sharedSecret));\n                            return new Promise((resolve, reject) => {\n                                jsonRpcResponsePromises[id] = {\n                                    resolve(result) {\n                                        switch (method) {\n                                            case 'authorize':\n                                            case 'reauthorize': {\n                                                const { wallet_uri_base } = result;\n                                                if (wallet_uri_base != null) {\n                                                    try {\n                                                        assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                    }\n                                                    catch (e) {\n                                                        reject(e);\n                                                        return;\n                                                    }\n                                                }\n                                                break;\n                                            }\n                                        }\n                                        resolve(result);\n                                    },\n                                    reject,\n                                };\n                            });\n                        }));\n                        try {\n                            resolve(yield callback(wallet));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                        finally {\n                            disposeSocket();\n                            socket.close();\n                        }\n                        break;\n                    }\n                }\n            });\n            let disposeSocket;\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = () => {\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = { __type: 'connecting', associationKeypair };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL_BINARY]);\n                socket.addEventListener('open', handleOpen);\n                socket.addEventListener('close', handleClose);\n                socket.addEventListener('error', handleError);\n                socket.addEventListener('message', handleMessage);\n                disposeSocket = () => {\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener('open', handleOpen);\n                    socket.removeEventListener('close', handleClose);\n                    socket.removeEventListener('error', handleError);\n                    socket.removeEventListener('message', handleMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n    });\n}\nfunction startRemoteScenario(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const websocketURL = `wss://${config === null || config === void 0 ? void 0 : config.remoteHostAuthority}/reflect`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (() => {\n            const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];\n            return () => (schedule.length > 1 ? schedule.shift() : schedule[0]);\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let encoding;\n        let state = { __type: 'disconnected' };\n        let socket;\n        let disposeSocket;\n        let decodeBytes = (evt) => __awaiter(this, void 0, void 0, function* () {\n            if (encoding == 'base64') { // base64 encoding\n                const message = yield evt.data;\n                return toUint8Array(message).buffer;\n            }\n            else {\n                return yield evt.data.arrayBuffer();\n            }\n        });\n        // Reflector Connection Phase\n        // here we connect to the reflector and wait for the REFLECTOR_ID message \n        // so we build the association URL and return that back to the caller\n        const associationUrl = yield new Promise((resolve, reject) => {\n            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {\n                if (state.__type !== 'connecting') {\n                    console.warn('Expected adapter state to be `connecting` at the moment the websocket opens. ' +\n                        `Got \\`${state.__type}\\`.`);\n                    return;\n                }\n                if (socket.protocol.includes(WEBSOCKET_PROTOCOL_BASE64)) {\n                    encoding = 'base64';\n                }\n                else {\n                    encoding = 'binary';\n                }\n                socket.removeEventListener('open', handleOpen);\n            });\n            const handleClose = (evt) => {\n                if (evt.wasClean) {\n                    state = { __type: 'disconnected' };\n                }\n                else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt) => __awaiter(this, void 0, void 0, function* () {\n                disposeSocket();\n                if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                }\n                else {\n                    yield new Promise((resolve) => {\n                        const retryDelayMs = getNextRetryDelayMs();\n                        retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                    });\n                    attemptSocketConnection();\n                }\n            });\n            const handleReflectorIdMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                const responseBuffer = yield decodeBytes(evt);\n                if (state.__type === 'connecting') {\n                    if (responseBuffer.byteLength == 0) {\n                        throw new Error('Encountered unexpected message while connecting');\n                    }\n                    const reflectorId = getReflectorIdFromByteArray(responseBuffer);\n                    state = {\n                        __type: 'reflector_id_received',\n                        reflectorId: reflectorId\n                    };\n                    const associationUrl = yield getRemoteAssociateAndroidIntentURL(associationKeypair.publicKey, config.remoteHostAuthority, reflectorId, config === null || config === void 0 ? void 0 : config.baseUri);\n                    socket.removeEventListener('message', handleReflectorIdMessage);\n                    resolve(associationUrl);\n                }\n            });\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = () => {\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = { __type: 'connecting', associationKeypair };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL_BINARY, WEBSOCKET_PROTOCOL_BASE64]);\n                socket.addEventListener('open', handleOpen);\n                socket.addEventListener('close', handleClose);\n                socket.addEventListener('error', handleError);\n                socket.addEventListener('message', handleReflectorIdMessage);\n                disposeSocket = () => {\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener('open', handleOpen);\n                    socket.removeEventListener('close', handleClose);\n                    socket.removeEventListener('error', handleError);\n                    socket.removeEventListener('message', handleReflectorIdMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n        // Wallet Connection Phase\n        // here we return the association URL (containing the reflector ID) to the caller + \n        // a promise that will resolve the MobileWallet object once the wallet connects.\n        let sessionEstablished = false;\n        let handleClose;\n        return { associationUrl, close: () => {\n                socket.close();\n                handleClose();\n            }, wallet: new Promise((resolve, reject) => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const jsonRpcResponsePromises = {};\n                const handleMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                    const responseBuffer = yield decodeBytes(evt);\n                    switch (state.__type) {\n                        case 'reflector_id_received':\n                            if (responseBuffer.byteLength !== 0) {\n                                throw new Error('Encountered unexpected message while awaiting reflection');\n                            }\n                            const ecdhKeypair = yield generateECDHKeypair();\n                            const binaryMsg = yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey);\n                            if (encoding == 'base64') {\n                                socket.send(fromUint8Array$1(binaryMsg));\n                            }\n                            else {\n                                socket.send(binaryMsg);\n                            }\n                            state = {\n                                __type: 'hello_req_sent',\n                                associationPublicKey: associationKeypair.publicKey,\n                                ecdhPrivateKey: ecdhKeypair.privateKey,\n                            };\n                            break;\n                        case 'connected':\n                            try {\n                                const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                    throw new Error('Encrypted message has invalid sequence number');\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                                const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                                delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                                responsePromise.resolve(jsonRpcMessage.result);\n                            }\n                            catch (e) {\n                                if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                    const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    responsePromise.reject(e);\n                                }\n                                else {\n                                    throw e;\n                                }\n                            }\n                            break;\n                        case 'hello_req_sent': {\n                            const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                            const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                            const sessionProperties = sessionPropertiesBuffer.byteLength !== 0\n                                ? yield (() => __awaiter(this, void 0, void 0, function* () {\n                                    const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                    const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                    if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                        throw new Error('Encrypted message has invalid sequence number');\n                                    }\n                                    lastKnownInboundSequenceNumber = sequenceNumber;\n                                    return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                                }))() : { protocol_version: 'legacy' };\n                            state = { __type: 'connected', sharedSecret, sessionProperties };\n                            const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter(this, void 0, void 0, function* () {\n                                const id = nextJsonRpcMessageId++;\n                                const binaryMsg = yield encryptJsonRpcMessage({\n                                    id,\n                                    jsonrpc: '2.0',\n                                    method,\n                                    params: params !== null && params !== void 0 ? params : {},\n                                }, sharedSecret);\n                                if (encoding == 'base64') {\n                                    socket.send(fromUint8Array$1(binaryMsg));\n                                }\n                                else {\n                                    socket.send(binaryMsg);\n                                }\n                                return new Promise((resolve, reject) => {\n                                    jsonRpcResponsePromises[id] = {\n                                        resolve(result) {\n                                            switch (method) {\n                                                case 'authorize':\n                                                case 'reauthorize': {\n                                                    const { wallet_uri_base } = result;\n                                                    if (wallet_uri_base != null) {\n                                                        try {\n                                                            assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                        }\n                                                        catch (e) {\n                                                            reject(e);\n                                                            return;\n                                                        }\n                                                    }\n                                                    break;\n                                                }\n                                            }\n                                            resolve(result);\n                                        },\n                                        reject,\n                                    };\n                                });\n                            }));\n                            sessionEstablished = true;\n                            try {\n                                resolve(wallet);\n                            }\n                            catch (e) {\n                                reject(e);\n                            }\n                            break;\n                        }\n                    }\n                });\n                socket.addEventListener('message', handleMessage);\n                handleClose = () => {\n                    socket.removeEventListener('message', handleMessage);\n                    disposeSocket();\n                    if (!sessionEstablished) {\n                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session was closed before connection.`, { closeEvent: new CloseEvent('socket was closed before connection') }));\n                    }\n                };\n            }) };\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYS1tb2JpbGUrbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sQDIuMi41X0Bzb2xhbmErd2FsbGV0LWFkYXB0ZXItYmFzZUAwLjkuMjdfX2Q4ZmY3YTljYzY0MzdiNGE0ZTMxMTZkN2IzNDY4ZjNlL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS9tb2JpbGUtd2FsbGV0LWFkYXB0ZXItcHJvdG9jb2wvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNiOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0NBQWdDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxxRkFBdUI7QUFDbEM7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsa0JBQWtCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTEFBaUwsbUVBQW1FO0FBQ3BQO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMOztBQUUyUSIsInNvdXJjZXMiOlsiL1VzZXJzL3N1a2FudGdob3NoL0NvZGUvU29sYW5hL2JldGZvbGlvL25vZGVfbW9kdWxlcy8ucG5wbS9Ac29sYW5hLW1vYmlsZSttb2JpbGUtd2FsbGV0LWFkYXB0ZXItcHJvdG9jb2xAMi4yLjVfQHNvbGFuYSt3YWxsZXQtYWRhcHRlci1iYXNlQDAuOS4yN19fZDhmZjdhOWNjNjQzN2I0YTRlMzExNmQ3YjM0NjhmM2Uvbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC9saWIvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNpZ25Jbk1lc3NhZ2VUZXh0IH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbCc7XG5pbXBvcnQgeyBnZXRCYXNlNThEZWNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3Mtc3RyaW5ncyc7XG5cbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmNvbnN0IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUgPSB7XG4gICAgRVJST1JfQVNTT0NJQVRJT05fUE9SVF9PVVRfT0ZfUkFOR0U6ICdFUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRScsXG4gICAgRVJST1JfUkVGTEVDVE9SX0lEX09VVF9PRl9SQU5HRTogJ0VSUk9SX1JFRkxFQ1RPUl9JRF9PVVRfT0ZfUkFOR0UnLFxuICAgIEVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkw6ICdFUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMJyxcbiAgICBFUlJPUl9TRUNVUkVfQ09OVEVYVF9SRVFVSVJFRDogJ0VSUk9SX1NFQ1VSRV9DT05URVhUX1JFUVVJUkVEJyxcbiAgICBFUlJPUl9TRVNTSU9OX0NMT1NFRDogJ0VSUk9SX1NFU1NJT05fQ0xPU0VEJyxcbiAgICBFUlJPUl9TRVNTSU9OX1RJTUVPVVQ6ICdFUlJPUl9TRVNTSU9OX1RJTUVPVVQnLFxuICAgIEVSUk9SX1dBTExFVF9OT1RfRk9VTkQ6ICdFUlJPUl9XQUxMRVRfTk9UX0ZPVU5EJyxcbiAgICBFUlJPUl9JTlZBTElEX1BST1RPQ09MX1ZFUlNJT046ICdFUlJPUl9JTlZBTElEX1BST1RPQ09MX1ZFUlNJT04nLFxuICAgIEVSUk9SX0JST1dTRVJfTk9UX1NVUFBPUlRFRDogJ0VSUk9SX0JST1dTRVJfTk9UX1NVUFBPUlRFRCcsXG59O1xuY2xhc3MgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgW2NvZGUsIG1lc3NhZ2UsIGRhdGFdID0gYXJncztcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3InO1xuICAgIH1cbn1cbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmNvbnN0IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yQ29kZSA9IHtcbiAgICAvLyBLZWVwIHRoZXNlIGluIHN5bmMgd2l0aCBgbW9iaWxld2FsbGV0YWRhcHRlci9jb21tb24vUHJvdG9jb2xDb250cmFjdC5qYXZhYC5cbiAgICBFUlJPUl9BVVRIT1JJWkFUSU9OX0ZBSUxFRDogLTEsXG4gICAgRVJST1JfSU5WQUxJRF9QQVlMT0FEUzogLTIsXG4gICAgRVJST1JfTk9UX1NJR05FRDogLTMsXG4gICAgRVJST1JfTk9UX1NVQk1JVFRFRDogLTQsXG4gICAgRVJST1JfVE9PX01BTllfUEFZTE9BRFM6IC01LFxuICAgIEVSUk9SX0FUVEVTVF9PUklHSU5fQU5EUk9JRDogLTEwMCxcbn07XG5jbGFzcyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IFtqc29uUnBjTWVzc2FnZUlkLCBjb2RlLCBtZXNzYWdlLCBkYXRhXSA9IGFyZ3M7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmpzb25ScGNNZXNzYWdlSWQgPSBqc29uUnBjTWVzc2FnZUlkO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3InO1xuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICAgIHJldHVybiB3aW5kb3cuYnRvYShpbnB1dCk7XG59XG5mdW5jdGlvbiBmcm9tVWludDhBcnJheSQxKGJ5dGVBcnJheSwgdXJsc2FmZSkge1xuICAgIGNvbnN0IGJhc2U2NCA9IHdpbmRvdy5idG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuY2FsbChudWxsLCAuLi5ieXRlQXJyYXkpKTtcbiAgICBpZiAodXJsc2FmZSkge1xuICAgICAgICByZXR1cm4gYmFzZTY0XG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYmFzZTY0O1xufVxuZnVuY3Rpb24gdG9VaW50OEFycmF5KGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2luZG93XG4gICAgICAgIC5hdG9iKGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhlbGxvUmVxKGVjZGhQdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpclByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXlCdWZmZXIgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgZWNkaFB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlciA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuc2lnbih7IGhhc2g6ICdTSEEtMjU2JywgbmFtZTogJ0VDRFNBJyB9LCBhc3NvY2lhdGlvbktleXBhaXJQcml2YXRlS2V5LCBwdWJsaWNLZXlCdWZmZXIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBVaW50OEFycmF5KHB1YmxpY0tleUJ1ZmZlci5ieXRlTGVuZ3RoICsgc2lnbmF0dXJlQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkocHVibGljS2V5QnVmZmVyKSwgMCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShzaWduYXR1cmVCdWZmZXIpLCBwdWJsaWNLZXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU0lXU01lc3NhZ2UocGF5bG9hZCkge1xuICAgIHJldHVybiBjcmVhdGVTaWduSW5NZXNzYWdlVGV4dChwYXlsb2FkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNJV1NNZXNzYWdlQmFzZTY0VXJsKHBheWxvYWQpIHtcbiAgICByZXR1cm4gZW5jb2RlKGNyZWF0ZVNJV1NNZXNzYWdlKHBheWxvYWQpKVxuICAgICAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpXG4gICAgICAgIC5yZXBsYWNlKC89KyQvLCAnJyk7IC8vIGNvbnZlcnQgdG8gYmFzZTY0dXJsIGVuY29kaW5nO1xufVxuXG4vLyBvcHRpb25hbCBmZWF0dXJlc1xuY29uc3QgU29sYW5hU2lnblRyYW5zYWN0aW9ucyA9ICdzb2xhbmE6c2lnblRyYW5zYWN0aW9ucyc7XG5jb25zdCBTb2xhbmFDbG9uZUF1dGhvcml6YXRpb24gPSAnc29sYW5hOmNsb25lQXV0aG9yaXphdGlvbic7XG5jb25zdCBTb2xhbmFTaWduSW5XaXRoU29sYW5hID0gJ3NvbGFuYTpzaWduSW5XaXRoU29sYW5hJztcblxuZnVuY3Rpb24gZnJvbVVpbnQ4QXJyYXkoYnl0ZUFycmF5KSB7XG4gICAgcmV0dXJuIGdldEJhc2U1OERlY29kZXIoKS5kZWNvZGUoYnl0ZUFycmF5KTtcbn1cbmZ1bmN0aW9uIGJhc2U2NFRvQmFzZTU4KGJhc2U2NEVuY29kZWRTdHJpbmcpIHtcbiAgICByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodG9VaW50OEFycmF5KGJhc2U2NEVuY29kZWRTdHJpbmcpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIE1vYmlsZVdhbGxldH0gcHJveHkgdGhhdCBoYW5kbGVzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGFuZCBBUEkgdG8gUlBDIGNvbnZlcnNpb24uXG4gKlxuICogQHBhcmFtIHByb3RvY29sVmVyc2lvbiB0aGUgcHJvdG9jb2wgdmVyc2lvbiBpbiB1c2UgZm9yIHRoaXMgc2Vzc2lvbi9yZXF1ZXN0XG4gKiBAcGFyYW0gcHJvdG9jb2xSZXF1ZXN0SGFuZGxlciBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgc2VuZGluZyB0aGUgUlBDIHJlcXVlc3QgdG8gdGhlIHdhbGxldCBlbmRwb2ludC5cbiAqIEByZXR1cm5zIGEge0BsaW5rIE1vYmlsZVdhbGxldH0gcHJveHlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9iaWxlV2FsbGV0UHJveHkocHJvdG9jb2xWZXJzaW9uLCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBwKSB7XG4gICAgICAgICAgICAvLyBXcmFwcGluZyBhIFByb3h5IGluIGEgcHJvbWlzZSByZXN1bHRzIGluIHRoZSBQcm94eSBiZWluZyBhc2tlZCBmb3IgYSAndGhlbicgcHJvcGVydHkgc28gbXVzdCBcbiAgICAgICAgICAgIC8vIHJldHVybiBudWxsIGlmICd0aGVuJyBpcyBjYWxsZWQgb24gdGhpcyBwcm94eSB0byBsZXQgdGhlICdyZXNvbHZlKCknIGNhbGwga25vdyB0aGlzIGlzIG5vdCBhIHByb21pc2UuXG4gICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mzg5MDkwNFxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAocCA9PT0gJ3RoZW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0W3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBmdW5jdGlvbiAoaW5wdXRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMgfSA9IGhhbmRsZU1vYmlsZVdhbGxldFJlcXVlc3QocCwgaW5wdXRQYXJhbXMsIHByb3RvY29sVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZXF1ZXN0IHRyaWVkIHRvIHNpZ24gaW4gYnV0IHRoZSB3YWxsZXQgZGlkIG5vdCByZXR1cm4gYSBzaWduIGluIHJlc3VsdCwgZmFsbGJhY2sgb24gbWVzc2FnZSBzaWduaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnYXV0aG9yaXplJyAmJiBwYXJhbXMuc2lnbl9pbl9wYXlsb2FkICYmICFyZXN1bHQuc2lnbl9pbl9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ3NpZ25faW5fcmVzdWx0J10gPSB5aWVsZCBzaWduSW5GYWxsYmFjayhwYXJhbXMuc2lnbl9pbl9wYXlsb2FkLCByZXN1bHQsIHByb3RvY29sUmVxdWVzdEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1vYmlsZVdhbGxldFJlc3BvbnNlKHAsIHJlc3VsdCwgcHJvdG9jb2xWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcF07XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogSGFuZGxlcyBhbGwge0BsaW5rIE1vYmlsZVdhbGxldH0gQVBJIHJlcXVlc3RzIGFuZCBkZXRlcm1pbmVzIHRoZSBjb3JyZWN0IE1XQSBSUEMgbWV0aG9kIGFuZCBwYXJhbXMgdG8gY2FsbC5cbiAqIFRoaXMgaGFuZGxlcyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmFzZWQgb24gdGhlIHByb3ZpZGVkIEBwcm90b2NvbFZlcnNpb24uXG4gKlxuICogQHBhcmFtIG1ldGhvZE5hbWUgdGhlIG5hbWUgb2Yge0BsaW5rIE1vYmlsZVdhbGxldH0gbWV0aG9kIHRoYXQgd2FzIGNhbGxlZFxuICogQHBhcmFtIG1ldGhvZFBhcmFtcyB0aGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAqIEBwYXJhbSBwcm90b2NvbFZlcnNpb24gdGhlIHByb3RvY29sIHZlcnNpb24gaW4gdXNlIGZvciB0aGlzIHNlc3Npb24vcmVxdWVzdFxuICogQHJldHVybnMgdGhlIFJQQyByZXF1ZXN0IG1ldGhvZCBhbmQgcGFyYW1zIHRoYXQgc2hvdWxkIGJlIHNlbnQgdG8gdGhlIHdhbGxldCBlbmRwb2ludFxuICovXG5mdW5jdGlvbiBoYW5kbGVNb2JpbGVXYWxsZXRSZXF1ZXN0KG1ldGhvZE5hbWUsIG1ldGhvZFBhcmFtcywgcHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgbGV0IHBhcmFtcyA9IG1ldGhvZFBhcmFtcztcbiAgICBsZXQgbWV0aG9kID0gbWV0aG9kTmFtZVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAucmVwbGFjZSgvW0EtWl0vZywgKGxldHRlcikgPT4gYF8ke2xldHRlci50b0xvd2VyQ2FzZSgpfWApXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICAgICAgICBjYXNlICdhdXRob3JpemUnOiB7XG4gICAgICAgICAgICBsZXQgeyBjaGFpbiB9ID0gcGFyYW1zO1xuICAgICAgICAgICAgaWYgKHByb3RvY29sVmVyc2lvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGFuYTp0ZXN0bmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAndGVzdG5ldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzb2xhbmE6ZGV2bmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAnZGV2bmV0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGFuYTptYWlubmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAnbWFpbm5ldC1iZXRhJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gcGFyYW1zLmNsdXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNsdXN0ZXIgPSBjaGFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGVzdG5ldCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rldm5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gYHNvbGFuYToke2NoYWlufWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYWlubmV0LWJldGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9ICdzb2xhbmE6bWFpbm5ldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMuY2hhaW4gPSBjaGFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZWF1dGhvcml6ZSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aF90b2tlbiwgaWRlbnRpdHkgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmIChhdXRoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm90b2NvbFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVnYWN5Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gJ3JlYXV0aG9yaXplJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHsgYXV0aF90b2tlbjogYXV0aF90b2tlbiwgaWRlbnRpdHk6IGlkZW50aXR5IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSAnYXV0aG9yaXplJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWV0aG9kLCBwYXJhbXMgfTtcbn1cbi8qKlxuICogSGFuZGxlcyBhbGwge0BsaW5rIE1vYmlsZVdhbGxldH0gQVBJIHJlc3BvbnNlcyBhbmQgbW9kaWZpZXMgdGhlIHJlc3BvbnNlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgaWYgbmVlZGVkXG4gKlxuICogQHBhcmFtIG1ldGhvZCB0aGUge0BsaW5rIE1vYmlsZVdhbGxldH0gbWV0aG9kIHRoYXQgd2FzIGNhbGxlZFxuICogQHBhcmFtIHJlc3BvbnNlIHRoZSBvcmlnaW5hbCByZXNwb25zZSB0aGF0IHdhcyByZXR1cm5lZCBieSB0aGUgbWV0aG9kIGNhbGxcbiAqIEBwYXJhbSBwcm90b2NvbFZlcnNpb24gdGhlIHByb3RvY29sIHZlcnNpb24gaW4gdXNlIGZvciB0aGlzIHNlc3Npb24vcmVxdWVzdFxuICogQHJldHVybnMgdGhlIHBvc3NpYmx5IG1vZGlmaWVkIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU1vYmlsZVdhbGxldFJlc3BvbnNlKG1ldGhvZCwgcmVzcG9uc2UsIHByb3RvY29sVmVyc2lvbikge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ2dldENhcGFiaWxpdGllcyc6IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgc3dpdGNoIChwcm90b2NvbFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWdhY3knOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVzID0gW1NvbGFuYVNpZ25UcmFuc2FjdGlvbnNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLnN1cHBvcnRzX2Nsb25lX2F1dGhvcml6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYXBhYmlsaXRpZXMpLCB7IGZlYXR1cmVzOiBmZWF0dXJlcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndjEnOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhcGFiaWxpdGllcyksIHsgc3VwcG9ydHNfc2lnbl9hbmRfc2VuZF90cmFuc2FjdGlvbnM6IHRydWUsIHN1cHBvcnRzX2Nsb25lX2F1dGhvcml6YXRpb246IGNhcGFiaWxpdGllcy5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFDbG9uZUF1dGhvcml6YXRpb24pIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBzaWduSW5GYWxsYmFjayhzaWduSW5QYXlsb2FkLCBhdXRob3JpemF0aW9uUmVzdWx0LCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IChfYSA9IHNpZ25JblBheWxvYWQuZG9tYWluKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHNbMF0uYWRkcmVzcztcbiAgICAgICAgY29uc3Qgc2l3c01lc3NhZ2UgPSBjcmVhdGVTSVdTTWVzc2FnZUJhc2U2NFVybChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNpZ25JblBheWxvYWQpLCB7IGRvbWFpbiwgYWRkcmVzczogYmFzZTY0VG9CYXNlNTgoYWRkcmVzcykgfSkpO1xuICAgICAgICBjb25zdCBzaWduTWVzc2FnZVJlc3VsdCA9IHlpZWxkIHByb3RvY29sUmVxdWVzdEhhbmRsZXIoJ3NpZ25fbWVzc2FnZXMnLCB7XG4gICAgICAgICAgICBhZGRyZXNzZXM6IFthZGRyZXNzXSxcbiAgICAgICAgICAgIHBheWxvYWRzOiBbc2l3c01lc3NhZ2VdXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduZWRQYXlsb2FkID0gdG9VaW50OEFycmF5KHNpZ25NZXNzYWdlUmVzdWx0LnNpZ25lZF9wYXlsb2Fkc1swXSk7XG4gICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBmcm9tVWludDhBcnJheSQxKHNpZ25lZFBheWxvYWQuc2xpY2UoMCwgc2lnbmVkUGF5bG9hZC5sZW5ndGggLSA2NCkpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBmcm9tVWludDhBcnJheSQxKHNpZ25lZFBheWxvYWQuc2xpY2Uoc2lnbmVkUGF5bG9hZC5sZW5ndGggLSA2NCkpO1xuICAgICAgICBjb25zdCBzaWduSW5SZXN1bHQgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZDogc29tZSB3YWxsZXRzIGhhdmUgYmVlbiBvYnNlcnZlZCB0byBvbmx5IHJlcGx5IHdpdGggdGhlIG1lc3NhZ2Ugc2lnbmF0dXJlLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBub24tY29tcGxpYW50IHdpdGggdGhlIHNwZWMsIGJ1dCBpbiB0aGUgaW50ZXJlc3Qgb2YgbWF4aW1pemluZyBjb21wYXRpYmlsaXR5LFxuICAgICAgICAgICAgLy8gZGV0ZWN0IHRoaXMgY2FzZSBhbmQgcmV1c2UgdGhlIG9yaWdpbmFsIG1lc3NhZ2UuXG4gICAgICAgICAgICBzaWduZWRfbWVzc2FnZTogc2lnbmVkTWVzc2FnZS5sZW5ndGggPT0gMCA/IHNpd3NNZXNzYWdlIDogc2lnbmVkTWVzc2FnZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2lnbkluUmVzdWx0O1xuICAgIH0pO1xufVxuXG5jb25zdCBTRVFVRU5DRV9OVU1CRVJfQllURVMgPSA0O1xuZnVuY3Rpb24gY3JlYXRlU2VxdWVuY2VOdW1iZXJWZWN0b3Ioc2VxdWVuY2VOdW1iZXIpIHtcbiAgICBpZiAoc2VxdWVuY2VOdW1iZXIgPj0gNDI5NDk2NzI5Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGJvdW5kIHNlcXVlbmNlIG51bWJlciBvdmVyZmxvdy4gVGhlIG1heGltdW0gc2VxdWVuY2UgbnVtYmVyIGlzIDMyLWJ5dGVzLicpO1xuICAgIH1cbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgQXJyYXlCdWZmZXIoU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVBcnJheSk7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgc2VxdWVuY2VOdW1iZXIsIC8qIGxpdHRsZUVuZGlhbiAqLyBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSk7XG59XG5cbmNvbnN0IElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyA9IDEyO1xuY29uc3QgRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyA9IDY1O1xuZnVuY3Rpb24gZW5jcnlwdE1lc3NhZ2UocGxhaW50ZXh0LCBzZXF1ZW5jZU51bWJlciwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBjcmVhdGVTZXF1ZW5jZU51bWJlclZlY3RvcihzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTKTtcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhpbml0aWFsaXphdGlvblZlY3Rvcik7XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoZ2V0QWxnb3JpdGhtUGFyYW1zKHNlcXVlbmNlTnVtYmVyVmVjdG9yLCBpbml0aWFsaXphdGlvblZlY3RvciksIHNoYXJlZFNlY3JldCwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBsYWludGV4dCkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBVaW50OEFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yLmJ5dGVMZW5ndGggKyBpbml0aWFsaXphdGlvblZlY3Rvci5ieXRlTGVuZ3RoICsgY2lwaGVydGV4dC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKSwgMCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShpbml0aWFsaXphdGlvblZlY3RvciksIHNlcXVlbmNlTnVtYmVyVmVjdG9yLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dCksIHNlcXVlbmNlTnVtYmVyVmVjdG9yLmJ5dGVMZW5ndGggKyBpbml0aWFsaXphdGlvblZlY3Rvci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVjcnlwdE1lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBtZXNzYWdlLnNsaWNlKDAsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gbWVzc2FnZS5zbGljZShTRVFVRU5DRV9OVU1CRVJfQllURVMsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyArIElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyk7XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBtZXNzYWdlLnNsaWNlKFNFUVVFTkNFX05VTUJFUl9CWVRFUyArIElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyk7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dEJ1ZmZlciA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZGVjcnlwdChnZXRBbGdvcml0aG1QYXJhbXMoc2VxdWVuY2VOdW1iZXJWZWN0b3IsIGluaXRpYWxpemF0aW9uVmVjdG9yKSwgc2hhcmVkU2VjcmV0LCBjaXBoZXJ0ZXh0KTtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gZ2V0VXRmOERlY29kZXIoKS5kZWNvZGUocGxhaW50ZXh0QnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFsZ29yaXRobVBhcmFtcyhzZXF1ZW5jZU51bWJlciwgaW5pdGlhbGl6YXRpb25WZWN0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRpdGlvbmFsRGF0YTogc2VxdWVuY2VOdW1iZXIsXG4gICAgICAgIGl2OiBpbml0aWFsaXphdGlvblZlY3RvcixcbiAgICAgICAgbmFtZTogJ0FFUy1HQ00nLFxuICAgICAgICB0YWdMZW5ndGg6IDEyOCwgLy8gMTYgYnl0ZSB0YWcgPT4gMTI4IGJpdHNcbiAgICB9O1xufVxubGV0IF91dGY4RGVjb2RlcjtcbmZ1bmN0aW9uIGdldFV0ZjhEZWNvZGVyKCkge1xuICAgIGlmIChfdXRmOERlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgfVxuICAgIHJldHVybiBfdXRmOERlY29kZXI7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQXNzb2NpYXRpb25LZXlwYWlyKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgWydzaWduJ10gLyoga2V5VXNhZ2VzICovKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFQ0RIS2V5cGFpcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4geWllbGQgY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICBuYW1lOiAnRUNESCcsXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgWydkZXJpdmVLZXknLCAnZGVyaXZlQml0cyddIC8qIGtleVVzYWdlcyAqLyk7XG4gICAgfSk7XG59XG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85NDU4OTk2LzgwMjA0N1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhidWZmZXIpIHtcbiAgICBsZXQgYmluYXJ5ID0gJyc7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpaV0pO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LmJ0b2EoYmluYXJ5KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tQXNzb2NpYXRpb25Qb3J0KCkge1xuICAgIHJldHVybiBhc3NlcnRBc3NvY2lhdGlvblBvcnQoNDkxNTIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoNjU1MzUgLSA0OTE1MiArIDEpKSk7XG59XG5mdW5jdGlvbiBhc3NlcnRBc3NvY2lhdGlvblBvcnQocG9ydCkge1xuICAgIGlmIChwb3J0IDwgNDkxNTIgfHwgcG9ydCA+IDY1NTM1KSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRSwgYEFzc29jaWF0aW9uIHBvcnQgbnVtYmVyIG11c3QgYmUgYmV0d2VlbiA0OTE1MiBhbmQgNjU1MzUuICR7cG9ydH0gZ2l2ZW4uYCwgeyBwb3J0IH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9ydDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZCh1bnNhZmVCYXNlNjRFbmNvZGVkU3RyaW5nKSB7XG4gICAgcmV0dXJuIHVuc2FmZUJhc2U2NEVuY29kZWRTdHJpbmcucmVwbGFjZSgvWy8rPV0vZywgKG0pID0+ICh7XG4gICAgICAgICcvJzogJ18nLFxuICAgICAgICAnKyc6ICctJyxcbiAgICAgICAgJz0nOiAnLicsXG4gICAgfVttXSkpO1xufVxuXG5jb25zdCBJTlRFTlRfTkFNRSA9ICdzb2xhbmEtd2FsbGV0JztcbmZ1bmN0aW9uIGdldFBhdGhQYXJ0cyhwYXRoU3RyaW5nKSB7XG4gICAgcmV0dXJuIChwYXRoU3RyaW5nXG4gICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXNcbiAgICAgICAgLnJlcGxhY2UoLyheXFwvK3xcXC8rJCkvZywgJycpXG4gICAgICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBkaXJlY3Rvcmllc1xuICAgICAgICAuc3BsaXQoJy8nKSk7XG59XG5mdW5jdGlvbiBnZXRJbnRlbnRVUkwobWV0aG9kUGF0aG5hbWUsIGludGVudFVybEJhc2UpIHtcbiAgICBsZXQgYmFzZVVybCA9IG51bGw7XG4gICAgaWYgKGludGVudFVybEJhc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKGludGVudFVybEJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgaWYgKChiYXNlVXJsID09PSBudWxsIHx8IGJhc2VVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJhc2VVcmwucHJvdG9jb2wpICE9PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdCYXNlIFVSTHMgc3VwcGxpZWQgYnkgd2FsbGV0cyBtdXN0IGJlIHZhbGlkIGBodHRwc2AgVVJMcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJhc2VVcmwgfHwgKGJhc2VVcmwgPSBuZXcgVVJMKGAke0lOVEVOVF9OQU1FfTovYCkpO1xuICAgIGNvbnN0IHBhdGhuYW1lID0gbWV0aG9kUGF0aG5hbWUuc3RhcnRzV2l0aCgnLycpXG4gICAgICAgID8gLy8gTWV0aG9kIGlzIGFuIGFic29sdXRlIHBhdGguIFJlcGxhY2UgaXQgd2hvbGVzYWxlLlxuICAgICAgICAgICAgbWV0aG9kUGF0aG5hbWVcbiAgICAgICAgOiAvLyBNZXRob2QgaXMgYSByZWxhdGl2ZSBwYXRoLiBNZXJnZSBpdCB3aXRoIHRoZSBleGlzdGluZyBvbmUuXG4gICAgICAgICAgICBbLi4uZ2V0UGF0aFBhcnRzKGJhc2VVcmwucGF0aG5hbWUpLCAuLi5nZXRQYXRoUGFydHMobWV0aG9kUGF0aG5hbWUpXS5qb2luKCcvJyk7XG4gICAgcmV0dXJuIG5ldyBVUkwocGF0aG5hbWUsIGJhc2VVcmwpO1xufVxuZnVuY3Rpb24gZ2V0QXNzb2NpYXRlQW5kcm9pZEludGVudFVSTChhc3NvY2lhdGlvblB1YmxpY0tleSwgcHV0YXRpdmVQb3J0LCBhc3NvY2lhdGlvblVSTEJhc2UsIHByb3RvY29sVmVyc2lvbnMgPSBbJ3YxJ10pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvblBvcnQgPSBhc3NlcnRBc3NvY2lhdGlvblBvcnQocHV0YXRpdmVQb3J0KTtcbiAgICAgICAgY29uc3QgZXhwb3J0ZWRLZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgYXNzb2NpYXRpb25QdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBlbmNvZGVkS2V5ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhleHBvcnRlZEtleSk7XG4gICAgICAgIGNvbnN0IHVybCA9IGdldEludGVudFVSTCgndjEvYXNzb2NpYXRlL2xvY2FsJywgYXNzb2NpYXRpb25VUkxCYXNlKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2Fzc29jaWF0aW9uJywgZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZChlbmNvZGVkS2V5KSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdwb3J0JywgYCR7YXNzb2NpYXRpb25Qb3J0fWApO1xuICAgICAgICBwcm90b2NvbFZlcnNpb25zLmZvckVhY2goKHZlcnNpb24pID0+IHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCd2JywgdmVyc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlQXNzb2NpYXRlQW5kcm9pZEludGVudFVSTChhc3NvY2lhdGlvblB1YmxpY0tleSwgaG9zdEF1dGhvcml0eSwgcmVmbGVjdG9ySWQsIGFzc29jaWF0aW9uVVJMQmFzZSwgcHJvdG9jb2xWZXJzaW9ucyA9IFsndjEnXSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVkS2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ3JhdycsIGFzc29jaWF0aW9uUHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZW5jb2RlZEtleSA9IGFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcoZXhwb3J0ZWRLZXkpO1xuICAgICAgICBjb25zdCB1cmwgPSBnZXRJbnRlbnRVUkwoJ3YxL2Fzc29jaWF0ZS9yZW1vdGUnLCBhc3NvY2lhdGlvblVSTEJhc2UpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYXNzb2NpYXRpb24nLCBnZXRTdHJpbmdXaXRoVVJMVW5zYWZlQ2hhcmFjdGVyc1JlcGxhY2VkKGVuY29kZWRLZXkpKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3JlZmxlY3RvcicsIGAke2hvc3RBdXRob3JpdHl9YCk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdpZCcsIGAke2Zyb21VaW50OEFycmF5JDEocmVmbGVjdG9ySWQsIHRydWUpfWApO1xuICAgICAgICBwcm90b2NvbFZlcnNpb25zLmZvckVhY2goKHZlcnNpb24pID0+IHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCd2JywgdmVyc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBlbmNyeXB0SnNvblJwY01lc3NhZ2UoanNvblJwY01lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IEpTT04uc3RyaW5naWZ5KGpzb25ScGNNZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBqc29uUnBjTWVzc2FnZS5pZDtcbiAgICAgICAgcmV0dXJuIGVuY3J5cHRNZXNzYWdlKHBsYWludGV4dCwgc2VxdWVuY2VOdW1iZXIsIHNoYXJlZFNlY3JldCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0SnNvblJwY01lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0geWllbGQgZGVjcnlwdE1lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgY29uc3QganNvblJwY01lc3NhZ2UgPSBKU09OLnBhcnNlKHBsYWludGV4dCk7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChqc29uUnBjTWVzc2FnZSwgJ2Vycm9yJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcihqc29uUnBjTWVzc2FnZS5pZCwganNvblJwY01lc3NhZ2UuZXJyb3IuY29kZSwganNvblJwY01lc3NhZ2UuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb25ScGNNZXNzYWdlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhlbGxvUnNwKHBheWxvYWRCdWZmZXIsIC8vIFRoZSBYOS42Mi1lbmNvZGVkIHdhbGxldCBlbmRwb2ludCBlcGhlbWVyYWwgRUNESCBwdWJsaWMga2V5cG9pbnQuXG5hc3NvY2lhdGlvblB1YmxpY0tleSwgZWNkaFByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBbYXNzb2NpYXRpb25QdWJsaWNLZXlCdWZmZXIsIHdhbGxldFB1YmxpY0tleV0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgYXNzb2NpYXRpb25QdWJsaWNLZXkpLFxuICAgICAgICAgICAgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHBheWxvYWRCdWZmZXIuc2xpY2UoMCwgRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyksIHsgbmFtZTogJ0VDREgnLCBuYW1lZEN1cnZlOiAnUC0yNTYnIH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbXSAvKiBrZXlVc2FnZXMgKi8pLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKHsgbmFtZTogJ0VDREgnLCBwdWJsaWM6IHdhbGxldFB1YmxpY0tleSB9LCBlY2RoUHJpdmF0ZUtleSwgMjU2KTtcbiAgICAgICAgY29uc3QgZWNkaFNlY3JldEtleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBzaGFyZWRTZWNyZXQsICdIS0RGJywgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnZGVyaXZlS2V5J10gLyoga2V5VXNhZ2VzICovKTtcbiAgICAgICAgY29uc3QgYWVzS2V5TWF0ZXJpYWxWYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleSh7XG4gICAgICAgICAgICBuYW1lOiAnSEtERicsXG4gICAgICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICAgICAgICBzYWx0OiBuZXcgVWludDhBcnJheShhc3NvY2lhdGlvblB1YmxpY0tleUJ1ZmZlciksXG4gICAgICAgICAgICBpbmZvOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9LCBlY2RoU2VjcmV0S2V5LCB7IG5hbWU6ICdBRVMtR0NNJywgbGVuZ3RoOiAxMjggfSwgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgICAgICByZXR1cm4gYWVzS2V5TWF0ZXJpYWxWYWw7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2Vzc2lvblByb3BzKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IHlpZWxkIGRlY3J5cHRNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgIGNvbnN0IGpzb25Qcm9wZXJ0aWVzID0gSlNPTi5wYXJzZShwbGFpbnRleHQpO1xuICAgICAgICBsZXQgcHJvdG9jb2xWZXJzaW9uID0gJ2xlZ2FjeSc7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChqc29uUHJvcGVydGllcywgJ3YnKSkge1xuICAgICAgICAgICAgc3dpdGNoIChqc29uUHJvcGVydGllcy52KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3YxJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xWZXJzaW9uID0gJ3YxJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVnYWN5JzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xWZXJzaW9uID0gJ2xlZ2FjeSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9JTlZBTElEX1BST1RPQ09MX1ZFUlNJT04sIGBVbmtub3duL3Vuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7anNvblByb3BlcnRpZXMudn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIHByb3RvY29sX3ZlcnNpb246IHByb3RvY29sVmVyc2lvblxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgQnJvd3NlciA9IHtcbiAgICBGaXJlZm94OiAwLFxuICAgIE90aGVyOiAxLFxufTtcbmZ1bmN0aW9uIGFzc2VydFVucmVhY2hhYmxlKHgpIHtcbiAgICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveC8nKSAhPT0gLTEgPyBCcm93c2VyLkZpcmVmb3ggOiBCcm93c2VyLk90aGVyO1xufVxuZnVuY3Rpb24gZ2V0RGV0ZWN0aW9uUHJvbWlzZSgpIHtcbiAgICAvLyBDaHJvbWUgYW5kIG90aGVycyBzaWxlbnRseSBmYWlsIGlmIGEgY3VzdG9tIHByb3RvY29sIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgLy8gRm9yIHRoZXNlLCB3ZSB3YWl0IHRvIHNlZSBpZiB0aGUgYnJvd3NlciBpcyBuYXZpZ2F0ZWQgYXdheSBmcm9tIGluXG4gICAgLy8gYSByZWFzb25hYmxlIGFtb3VudCBvZiB0aW1lIChpZS4gdGhlIG5hdGl2ZSB3YWxsZXQgb3BlbmVkKS5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKTtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgfSk7XG59XG5sZXQgX2ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIGxhdW5jaFVybFRocm91Z2hIaWRkZW5GcmFtZSh1cmwpIHtcbiAgICBpZiAoX2ZyYW1lID09IG51bGwpIHtcbiAgICAgICAgX2ZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIF9mcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKF9mcmFtZSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgX2ZyYW1lLmNvbnRlbnRXaW5kb3cubG9jYXRpb24uaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gbGF1bmNoQXNzb2NpYXRpb24oYXNzb2NpYXRpb25VcmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoYXNzb2NpYXRpb25VcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNzb2NpYXRpb24gVVJMIGlzIGFuIEFuZHJvaWQgJ0FwcCBMaW5rJyBvciBpT1MgJ1VuaXZlcnNhbCBMaW5rJy5cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSByZWd1bGFyIHdlYiBVUkxzIHRoYXQgYXJlIGRlc2lnbmVkIHRvIGxhdW5jaCBhbiBhcHAgaWYgaXRcbiAgICAgICAgICAgIC8vIGlzIGluc3RhbGxlZCBvciBsb2FkIHRoZSBhY3R1YWwgdGFyZ2V0IHdlYnBhZ2UgaWYgbm90LlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihhc3NvY2lhdGlvblVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNzb2NpYXRpb24gVVJMIGhhcyBhIGN1c3RvbSBwcm90b2NvbCAoZWcuIGBzb2xhbmEtd2FsbGV0OmApXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChicm93c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQnJvd3Nlci5GaXJlZm94OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBjdXN0b20gcHJvdG9jb2wgaXMgbm90IHN1cHBvcnRlZCBpbiBGaXJlZm94LCBpdCB0aHJvd3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXVuY2hVcmxUaHJvdWdoSGlkZGVuRnJhbWUoYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCB0aGlzIGxpbmUsIGl0J3Mgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQnJvd3Nlci5PdGhlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0aW9uUHJvbWlzZSA9IGdldERldGVjdGlvblByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZGV0ZWN0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRVbnJlYWNoYWJsZShicm93c2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9XQUxMRVRfTk9UX0ZPVU5ELCAnRm91bmQgbm8gaW5zdGFsbGVkIHdhbGxldCB0aGF0IHN1cHBvcnRzIHRoZSBtb2JpbGUgd2FsbGV0IHByb3RvY29sLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdGFydFNlc3Npb24oYXNzb2NpYXRpb25QdWJsaWNLZXksIGFzc29jaWF0aW9uVVJMQmFzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbUFzc29jaWF0aW9uUG9ydCA9IGdldFJhbmRvbUFzc29jaWF0aW9uUG9ydCgpO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvblVybCA9IHlpZWxkIGdldEFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwoYXNzb2NpYXRpb25QdWJsaWNLZXksIHJhbmRvbUFzc29jaWF0aW9uUG9ydCwgYXNzb2NpYXRpb25VUkxCYXNlKTtcbiAgICAgICAgeWllbGQgbGF1bmNoQXNzb2NpYXRpb24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICByZXR1cm4gcmFuZG9tQXNzb2NpYXRpb25Qb3J0O1xuICAgIH0pO1xufVxuXG5jb25zdCBXRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcgPSB7XG4gICAgLyoqXG4gICAgICogMzAwIG1pbGxpc2Vjb25kcyBpcyBhIGdlbmVyYWxseSBhY2NlcHRlZCB0aHJlc2hvbGQgZm9yIHdoYXQgc29tZW9uZVxuICAgICAqIHdvdWxkIGNvbnNpZGVyIGFuIGFjY2VwdGFibGUgcmVzcG9uc2UgdGltZSBmb3IgYSB1c2VyIGludGVyZmFjZVxuICAgICAqIGFmdGVyIGhhdmluZyBwZXJmb3JtZWQgYSBsb3ctYXR0ZW50aW9uIHRhcHBpbmcgdGFzay4gV2Ugc2V0IHRoZSBpbml0aWFsXG4gICAgICogaW50ZXJ2YWwgYXQgd2hpY2ggd2Ugd2FpdCBmb3IgdGhlIHdhbGxldCB0byBzZXQgdXAgdGhlIHdlYnNvY2tldCBhdFxuICAgICAqIGhhbGYgdGhpcywgYXMgcGVyIHRoZSBOeXF1aXN0IGZyZXF1ZW5jeSwgd2l0aCBhIHByb2dyZXNzaXZlIGJhY2tvZmZcbiAgICAgKiBzZXF1ZW5jZSBmcm9tIHRoZXJlLiBUaGUgdG90YWwgd2FpdCB0aW1lIGlzIDMwcywgd2hpY2ggYWxsb3dzIGZvciB0aGVcbiAgICAgKiB1c2VyIHRvIGJlIHByZXNlbnRlZCB3aXRoIGEgZGlzYW1iaWd1YXRpb24gZGlhbG9nLCBzZWxlY3QgYSB3YWxsZXQsIGFuZFxuICAgICAqIGZvciB0aGUgd2FsbGV0IGFwcCB0byBzdWJzZXF1ZW50bHkgc3RhcnQuXG4gICAgICovXG4gICAgcmV0cnlEZWxheVNjaGVkdWxlTXM6IFsxNTAsIDE1MCwgMjAwLCA1MDAsIDUwMCwgNzUwLCA3NTAsIDEwMDBdLFxuICAgIHRpbWVvdXRNczogMzAwMDAsXG59O1xuY29uc3QgV0VCU09DS0VUX1BST1RPQ09MX0JJTkFSWSA9ICdjb20uc29sYW5hLm1vYmlsZXdhbGxldGFkYXB0ZXIudjEnO1xuY29uc3QgV0VCU09DS0VUX1BST1RPQ09MX0JBU0U2NCA9ICdjb20uc29sYW5hLm1vYmlsZXdhbGxldGFkYXB0ZXIudjEuYmFzZTY0JztcbmZ1bmN0aW9uIGFzc2VydFNlY3VyZUNvbnRleHQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFQ1VSRV9DT05URVhUX1JFUVVJUkVELCAnVGhlIG1vYmlsZSB3YWxsZXQgYWRhcHRlciBwcm90b2NvbCBtdXN0IGJlIHVzZWQgaW4gYSBzZWN1cmUgY29udGV4dCAoYGh0dHBzYCkuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRVcmlCYXNlKSB7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHdhbGxldFVyaUJhc2UpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdJbnZhbGlkIGJhc2UgVVJMIHN1cHBsaWVkIGJ5IHdhbGxldCcpO1xuICAgIH1cbiAgICBpZiAodXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCwgJ0Jhc2UgVVJMcyBzdXBwbGllZCBieSB3YWxsZXRzIG11c3QgYmUgdmFsaWQgYGh0dHBzYCBVUkxzJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KGJ5dGVBcnJheSkge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZUFycmF5KTtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MzIoMCwgLyogbGl0dGxlRW5kaWFuICovIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVZhckxvbmcoYnl0ZUFycmF5KSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5KSwgbCA9IGJ5dGVBcnJheS5ieXRlTGVuZ3RoLCBsaW1pdCA9IDEwLCB2YWx1ZSA9IDAsIG9mZnNldCA9IDAsIGI7XG4gICAgZG8ge1xuICAgICAgICBpZiAob2Zmc2V0ID49IGwgfHwgb2Zmc2V0ID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRmFpbGVkIHRvIGRlY29kZSB2YXJpbnQnKTtcbiAgICAgICAgYiA9IGJ5dGVzW29mZnNldCsrXTtcbiAgICAgICAgdmFsdWUgfD0gKGIgJiAweDdGKSA8PCAoNyAqIG9mZnNldCk7XG4gICAgfSB3aGlsZSAoYiA+PSAweDgwKTtcbiAgICByZXR1cm4geyB2YWx1ZSwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBnZXRSZWZsZWN0b3JJZEZyb21CeXRlQXJyYXkoYnl0ZUFycmF5KSB7XG4gICAgbGV0IHsgdmFsdWU6IGxlbmd0aCwgb2Zmc2V0IH0gPSBkZWNvZGVWYXJMb25nKGJ5dGVBcnJheSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xufVxuZnVuY3Rpb24gdHJhbnNhY3QoY2FsbGJhY2ssIGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGFzc2VydFNlY3VyZUNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25LZXlwYWlyID0geWllbGQgZ2VuZXJhdGVBc3NvY2lhdGlvbktleXBhaXIoKTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvblBvcnQgPSB5aWVsZCBzdGFydFNlc3Npb24oYXNzb2NpYXRpb25LZXlwYWlyLnB1YmxpY0tleSwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmJhc2VVcmkpO1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXRVUkwgPSBgd3M6Ly9sb2NhbGhvc3Q6JHtzZXNzaW9uUG9ydH0vc29sYW5hLXdhbGxldGA7XG4gICAgICAgIGxldCBjb25uZWN0aW9uU3RhcnRUaW1lO1xuICAgICAgICBjb25zdCBnZXROZXh0UmV0cnlEZWxheU1zID0gKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlID0gWy4uLldFQlNPQ0tFVF9DT05ORUNUSU9OX0NPTkZJRy5yZXRyeURlbGF5U2NoZWR1bGVNc107XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gKHNjaGVkdWxlLmxlbmd0aCA+IDEgPyBzY2hlZHVsZS5zaGlmdCgpIDogc2NoZWR1bGVbMF0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICBsZXQgbmV4dEpzb25ScGNNZXNzYWdlSWQgPSAxO1xuICAgICAgICBsZXQgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICAgICAgbGV0IHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgc29ja2V0O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNvbnN0IGpzb25ScGNSZXNwb25zZVByb21pc2VzID0ge307XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVPcGVuID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5fX3R5cGUgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGFkYXB0ZXIgc3RhdGUgdG8gYmUgYGNvbm5lY3RpbmdgIGF0IHRoZSBtb21lbnQgdGhlIHdlYnNvY2tldCBvcGVucy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBgR290IFxcYCR7c3RhdGUuX190eXBlfVxcYC5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHZlcnNpb25zIG9mIHRoaXMgbGlicmFyeSBhbmQgd2FsbGV0bGliIGluY29ycmVjdGx5IGltcGxlbWVudGVkIHRoZSBNV0Egc2Vzc2lvbiBcbiAgICAgICAgICAgICAgICAvLyBlc3RhYmxpc2htZW50IHByb3RvY29sIGZvciBsb2NhbCBjb25uZWN0aW9ucy4gVGhlIGRhcHAgaXMgc3VwcG9zZWQgdG8gd2FpdCBmb3IgdGhlIFxuICAgICAgICAgICAgICAgIC8vIEFQUF9QSU5HIG1lc3NhZ2UgYmVmb3JlIHNlbmRpbmcgdGhlIEhFTExPX1JFUS4gSW5zdGVhZCwgdGhlIGRhcHAgd2FzIHNlbmRpbmcgdGhlIEhFTExPX1JFUSBcbiAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSB1cG9uIGNvbm5lY3Rpb24gdG8gdGhlIHdlYnNvY2tldCBzZXJ2ZXIgcmVnYXJkbGVzcyBvZiB3ZXRoZXIgb3Igbm90IGFuIFxuICAgICAgICAgICAgICAgIC8vIEFQUF9QSU5HIHdhcyBzZW50IGJ5IHRoZSB3YWxsZXQvd2Vic29ja2V0IHNlcnZlci4gV2UgbXVzdCBjb250aW51ZSB0byBzdXBwb3J0IHRoaXMgYmVoYXZpb3IgXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgdXNlciBpcyB1c2luZyBhIHdhbGxldCB0aGF0IGhhcyBub3QgdXBkYXRlZCB0aGVpciB3YWxsZXRsaWIgaW1wbGVtZW50YXRpb24uIFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXNzb2NpYXRpb25LZXlwYWlyIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlY2RoS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlRUNESEtleXBhaXIoKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBjcmVhdGVIZWxsb1JlcShlY2RoS2V5cGFpci5wdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpci5wcml2YXRlS2V5KSk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ2hlbGxvX3JlcV9zZW50JyxcbiAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25QdWJsaWNLZXk6IGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgIGVjZGhQcml2YXRlS2V5OiBlY2RoS2V5cGFpci5wcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNsb3NlID0gKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldnQud2FzQ2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Rpc2Nvbm5lY3RlZCcgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfU0VTU0lPTl9DTE9TRUQsIGBUaGUgd2FsbGV0IHNlc3Npb24gZHJvcHBlZCB1bmV4cGVjdGVkbHkgKCR7ZXZ0LmNvZGV9OiAke2V2dC5yZWFzb259KS5gLCB7IGNsb3NlRXZlbnQ6IGV2dCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVFcnJvciA9IChfZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gY29ubmVjdGlvblN0YXJ0VGltZSA+PSBXRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcudGltZW91dE1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfU0VTU0lPTl9USU1FT1VULCBgRmFpbGVkIHRvIGNvbm5lY3QgdG8gdGhlIHdhbGxldCB3ZWJzb2NrZXQgYXQgJHt3ZWJzb2NrZXRVUkx9LmApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeURlbGF5TXMgPSBnZXROZXh0UmV0cnlEZWxheU1zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeVdhaXRUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5TXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSB5aWVsZCBldnQuZGF0YS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUuX190eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlQnVmZmVyLmJ5dGVMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIHVuZXhwZWN0ZWQgbWVzc2FnZSB3aGlsZSBjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2RoS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlRUNESEtleXBhaXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHlpZWxkIGNyZWF0ZUhlbGxvUmVxKGVjZGhLZXlwYWlyLnB1YmxpY0tleSwgYXNzb2NpYXRpb25LZXlwYWlyLnByaXZhdGVLZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ2hlbGxvX3JlcV9zZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvblB1YmxpY0tleTogYXNzb2NpYXRpb25LZXlwYWlyLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSByZXNwb25zZUJ1ZmZlci5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGhhcyBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uUnBjTWVzc2FnZSA9IHlpZWxkIGRlY3J5cHRKc29uUnBjTWVzc2FnZShyZXNwb25zZUJ1ZmZlciwgc3RhdGUuc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb25ScGNSZXNwb25zZVByb21pc2VzW2pzb25ScGNNZXNzYWdlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShqc29uUnBjTWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGpzb25ScGNSZXNwb25zZVByb21pc2VzW2UuanNvblJwY01lc3NhZ2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tlLmpzb25ScGNNZXNzYWdlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGVsbG9fcmVxX3NlbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSByZWNlaXZlIGFuIEFQUF9QSU5HIG1lc3NhZ2UgKGVtcHR5IG1lc3NhZ2UpLCByZXNlbmQgdGhlIEhFTExPX1JFUSAoc2VlIGFib3ZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlQnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2RoS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlRUNESEtleXBhaXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBjcmVhdGVIZWxsb1JlcShlY2RoS2V5cGFpci5wdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpci5wcml2YXRlS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ2hlbGxvX3JlcV9zZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25QdWJsaWNLZXk6IGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjZGhQcml2YXRlS2V5OiBlY2RoS2V5cGFpci5wcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSB5aWVsZCBwYXJzZUhlbGxvUnNwKHJlc3BvbnNlQnVmZmVyLCBzdGF0ZS5hc3NvY2lhdGlvblB1YmxpY0tleSwgc3RhdGUuZWNkaFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIgPSByZXNwb25zZUJ1ZmZlci5zbGljZShFTkNPREVEX1BVQkxJQ19LRVlfTEVOR1RIX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geWllbGQgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBzZXNzaW9uUHJvcGVydGllc0J1ZmZlci5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlciAhPT0gKGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGhhcyBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTZXNzaW9uUHJvcHMoc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKCkgOiB7IHByb3RvY29sX3ZlcnNpb246ICdsZWdhY3knIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnY29ubmVjdGVkJywgc2hhcmVkU2VjcmV0LCBzZXNzaW9uUHJvcGVydGllcyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gY3JlYXRlTW9iaWxlV2FsbGV0UHJveHkoc2Vzc2lvblByb3BlcnRpZXMucHJvdG9jb2xfdmVyc2lvbiwgKG1ldGhvZCwgcGFyYW1zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBuZXh0SnNvblJwY01lc3NhZ2VJZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHlpZWxkIGVuY3J5cHRKc29uUnBjTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNoYXJlZFNlY3JldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25ScGNSZXNwb25zZVByb21pc2VzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXV0aG9yaXplJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVhdXRob3JpemUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdhbGxldF91cmlfYmFzZSB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGxldF91cmlfYmFzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRfdXJpX2Jhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHlpZWxkIGNhbGxiYWNrKHdhbGxldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2VTb2NrZXQ7XG4gICAgICAgICAgICBsZXQgcmV0cnlXYWl0VGltZW91dElkO1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2VTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnY29ubmVjdGluZycsIGFzc29jaWF0aW9uS2V5cGFpciB9O1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvblN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvY2tldCA9IG5ldyBXZWJTb2NrZXQod2Vic29ja2V0VVJMLCBbV0VCU09DS0VUX1BST1RPQ09MX0JJTkFSWV0pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmV0cnlXYWl0VGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhdHRlbXB0U29ja2V0Q29ubmVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHN0YXJ0UmVtb3RlU2NlbmFyaW8oY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgYXNzZXJ0U2VjdXJlQ29udGV4dCgpO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvbktleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUFzc29jaWF0aW9uS2V5cGFpcigpO1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXRVUkwgPSBgd3NzOi8vJHtjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcucmVtb3RlSG9zdEF1dGhvcml0eX0vcmVmbGVjdGA7XG4gICAgICAgIGxldCBjb25uZWN0aW9uU3RhcnRUaW1lO1xuICAgICAgICBjb25zdCBnZXROZXh0UmV0cnlEZWxheU1zID0gKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlID0gWy4uLldFQlNPQ0tFVF9DT05ORUNUSU9OX0NPTkZJRy5yZXRyeURlbGF5U2NoZWR1bGVNc107XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gKHNjaGVkdWxlLmxlbmd0aCA+IDEgPyBzY2hlZHVsZS5zaGlmdCgpIDogc2NoZWR1bGVbMF0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICBsZXQgbmV4dEpzb25ScGNNZXNzYWdlSWQgPSAxO1xuICAgICAgICBsZXQgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICAgICAgbGV0IGVuY29kaW5nO1xuICAgICAgICBsZXQgc3RhdGUgPSB7IF9fdHlwZTogJ2Rpc2Nvbm5lY3RlZCcgfTtcbiAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgbGV0IGRpc3Bvc2VTb2NrZXQ7XG4gICAgICAgIGxldCBkZWNvZGVCeXRlcyA9IChldnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PSAnYmFzZTY0JykgeyAvLyBiYXNlNjQgZW5jb2RpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0geWllbGQgZXZ0LmRhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvVWludDhBcnJheShtZXNzYWdlKS5idWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgZXZ0LmRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlZmxlY3RvciBDb25uZWN0aW9uIFBoYXNlXG4gICAgICAgIC8vIGhlcmUgd2UgY29ubmVjdCB0byB0aGUgcmVmbGVjdG9yIGFuZCB3YWl0IGZvciB0aGUgUkVGTEVDVE9SX0lEIG1lc3NhZ2UgXG4gICAgICAgIC8vIHNvIHdlIGJ1aWxkIHRoZSBhc3NvY2lhdGlvbiBVUkwgYW5kIHJldHVybiB0aGF0IGJhY2sgdG8gdGhlIGNhbGxlclxuICAgICAgICBjb25zdCBhc3NvY2lhdGlvblVybCA9IHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZU9wZW4gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLl9fdHlwZSAhPT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRXhwZWN0ZWQgYWRhcHRlciBzdGF0ZSB0byBiZSBgY29ubmVjdGluZ2AgYXQgdGhlIG1vbWVudCB0aGUgd2Vic29ja2V0IG9wZW5zLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBHb3QgXFxgJHtzdGF0ZS5fX3R5cGV9XFxgLmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucHJvdG9jb2wuaW5jbHVkZXMoV0VCU09DS0VUX1BST1RPQ09MX0JBU0U2NCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSAnYmFzZTY0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNsb3NlID0gKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldnQud2FzQ2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Rpc2Nvbm5lY3RlZCcgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfU0VTU0lPTl9DTE9TRUQsIGBUaGUgd2FsbGV0IHNlc3Npb24gZHJvcHBlZCB1bmV4cGVjdGVkbHkgKCR7ZXZ0LmNvZGV9OiAke2V2dC5yZWFzb259KS5gLCB7IGNsb3NlRXZlbnQ6IGV2dCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVFcnJvciA9IChfZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gY29ubmVjdGlvblN0YXJ0VGltZSA+PSBXRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcudGltZW91dE1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfU0VTU0lPTl9USU1FT1VULCBgRmFpbGVkIHRvIGNvbm5lY3QgdG8gdGhlIHdhbGxldCB3ZWJzb2NrZXQgYXQgJHt3ZWJzb2NrZXRVUkx9LmApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeURlbGF5TXMgPSBnZXROZXh0UmV0cnlEZWxheU1zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeVdhaXRUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5TXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVJlZmxlY3RvcklkTWVzc2FnZSA9IChldnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUJ1ZmZlciA9IHlpZWxkIGRlY29kZUJ5dGVzKGV2dCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLl9fdHlwZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgdW5leHBlY3RlZCBtZXNzYWdlIHdoaWxlIGNvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZsZWN0b3JJZCA9IGdldFJlZmxlY3RvcklkRnJvbUJ5dGVBcnJheShyZXNwb25zZUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgX190eXBlOiAncmVmbGVjdG9yX2lkX3JlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmxlY3RvcklkOiByZWZsZWN0b3JJZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvblVybCA9IHlpZWxkIGdldFJlbW90ZUFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwoYXNzb2NpYXRpb25LZXlwYWlyLnB1YmxpY0tleSwgY29uZmlnLnJlbW90ZUhvc3RBdXRob3JpdHksIHJlZmxlY3RvcklkLCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYmFzZVVyaSk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlUmVmbGVjdG9ySWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhc3NvY2lhdGlvblVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcmV0cnlXYWl0VGltZW91dElkO1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2VTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnY29ubmVjdGluZycsIGFzc29jaWF0aW9uS2V5cGFpciB9O1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvblN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvY2tldCA9IG5ldyBXZWJTb2NrZXQod2Vic29ja2V0VVJMLCBbV0VCU09DS0VUX1BST1RPQ09MX0JJTkFSWSwgV0VCU09DS0VUX1BST1RPQ09MX0JBU0U2NF0pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVJlZmxlY3RvcklkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChyZXRyeVdhaXRUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBoYW5kbGVDbG9zZSk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVSZWZsZWN0b3JJZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhbGxldCBDb25uZWN0aW9uIFBoYXNlXG4gICAgICAgIC8vIGhlcmUgd2UgcmV0dXJuIHRoZSBhc3NvY2lhdGlvbiBVUkwgKGNvbnRhaW5pbmcgdGhlIHJlZmxlY3RvciBJRCkgdG8gdGhlIGNhbGxlciArIFxuICAgICAgICAvLyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdGhlIE1vYmlsZVdhbGxldCBvYmplY3Qgb25jZSB0aGUgd2FsbGV0IGNvbm5lY3RzLlxuICAgICAgICBsZXQgc2Vzc2lvbkVzdGFibGlzaGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBoYW5kbGVDbG9zZTtcbiAgICAgICAgcmV0dXJuIHsgYXNzb2NpYXRpb25VcmwsIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2xvc2UoKTtcbiAgICAgICAgICAgIH0sIHdhbGxldDogbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgY29uc3QganNvblJwY1Jlc3BvbnNlUHJvbWlzZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gKGV2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUJ1ZmZlciA9IHlpZWxkIGRlY29kZUJ5dGVzKGV2dCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUuX190eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWZsZWN0b3JfaWRfcmVjZWl2ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgdW5leHBlY3RlZCBtZXNzYWdlIHdoaWxlIGF3YWl0aW5nIHJlZmxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluYXJ5TXNnID0geWllbGQgY3JlYXRlSGVsbG9SZXEoZWNkaEtleXBhaXIucHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nID09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKGZyb21VaW50OEFycmF5JDEoYmluYXJ5TXNnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChiaW5hcnlNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190eXBlOiAnaGVsbG9fcmVxX3NlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvblB1YmxpY0tleTogYXNzb2NpYXRpb25LZXlwYWlyLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWNkaFByaXZhdGVLZXk6IGVjZGhLZXlwYWlyLnByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSByZXNwb25zZUJ1ZmZlci5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlciAhPT0gKGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGhhcyBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uUnBjTWVzc2FnZSA9IHlpZWxkIGRlY3J5cHRKc29uUnBjTWVzc2FnZShyZXNwb25zZUJ1ZmZlciwgc3RhdGUuc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0ganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbanNvblJwY01lc3NhZ2UuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbanNvblJwY01lc3NhZ2UuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShqc29uUnBjTWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tlLmpzb25ScGNNZXNzYWdlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb25ScGNSZXNwb25zZVByb21pc2VzW2UuanNvblJwY01lc3NhZ2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hlbGxvX3JlcV9zZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHlpZWxkIHBhcnNlSGVsbG9Sc3AocmVzcG9uc2VCdWZmZXIsIHN0YXRlLmFzc29jaWF0aW9uUHVibGljS2V5LCBzdGF0ZS5lY2RoUHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIgPSByZXNwb25zZUJ1ZmZlci5zbGljZShFTkNPREVEX1BVQkxJQ19LRVlfTEVOR1RIX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uUHJvcGVydGllcyA9IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLmJ5dGVMZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB5aWVsZCAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBzZXNzaW9uUHJvcGVydGllc0J1ZmZlci5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBnZXRTZXF1ZW5jZU51bWJlckZyb21CeXRlQXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSAobGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGhhcyBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTZXNzaW9uUHJvcHMoc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpIDogeyBwcm90b2NvbF92ZXJzaW9uOiAnbGVnYWN5JyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBfX3R5cGU6ICdjb25uZWN0ZWQnLCBzaGFyZWRTZWNyZXQsIHNlc3Npb25Qcm9wZXJ0aWVzIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gY3JlYXRlTW9iaWxlV2FsbGV0UHJveHkoc2Vzc2lvblByb3BlcnRpZXMucHJvdG9jb2xfdmVyc2lvbiwgKG1ldGhvZCwgcGFyYW1zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbmV4dEpzb25ScGNNZXNzYWdlSWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluYXJ5TXNnID0geWllbGQgZW5jcnlwdEpzb25ScGNNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKGZyb21VaW50OEFycmF5JDEoYmluYXJ5TXNnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChiaW5hcnlNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWF1dGhvcml6ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdhbGxldF91cmlfYmFzZSB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXRfdXJpX2Jhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRfdXJpX2Jhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25Fc3RhYmxpc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh3YWxsZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9TRVNTSU9OX0NMT1NFRCwgYFRoZSB3YWxsZXQgc2Vzc2lvbiB3YXMgY2xvc2VkIGJlZm9yZSBjb25uZWN0aW9uLmAsIHsgY2xvc2VFdmVudDogbmV3IENsb3NlRXZlbnQoJ3NvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSBjb25uZWN0aW9uJykgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pIH07XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IFNvbGFuYUNsb25lQXV0aG9yaXphdGlvbiwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvciwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3JDb2RlLCBTb2xhbmFTaWduSW5XaXRoU29sYW5hLCBTb2xhbmFTaWduVHJhbnNhY3Rpb25zLCBzdGFydFJlbW90ZVNjZW5hcmlvLCB0cmFuc2FjdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@solana-mobile+mobile-wallet-adapter-protocol@2.2.5_@solana+wallet-adapter-base@0.9.27__d8ff7a9cc6437b4a4e3116d7b3468f3e/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\n");

/***/ })

};
;